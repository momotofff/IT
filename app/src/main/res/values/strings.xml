<resources>
    <string name="app_name">IT</string>
    <string name="start_motivation_text">Для меня долгое время было загадкой, как что-то очень дорогое и технологичное может быть столь бесполезным.
                                        И вскоре я осознал, что компьютер — это глупая машина, обладающая способностями выполнять невероятно умные вещи,
                                        тогда как программисты — это умные люди, у которых талант делать невероятные глупости. Короче, они нашли друг друга.
                                                                     Bill Bryson</string>
    <string name="start">НАЧАТЬ</string>
    <string name="empty_string"> </string>
    <string name="startbutton">start</string>
    <string name="todo">TODO</string>
    <string-array name="tips_of_the_day">
        <item>Цели тестирования могут отличаться, в зависимости от этапа разработки ПО, на котором оно проводится. К примеру, на этапе кодирования целью тестирования будет вызов как можно большего количества сбоев в работе программы, что позволит локализовать и исправить дефекты. В то же время, при приемочном тестировании необходимо  показать, что система работает правильно. В период сопровождения, тестирование в основном необходимо для того, чтобы  убедится в отсутствии новых багов, появившихся во время внесения изменений.</item>
        <item>Тестирование позволяет находить и исправлять дефекты,  тем самым снижая уровень риска и повышая качество продукта. Проверяются, в том числе, и места пользовательского интерфейса, где пользователь может сделать ошибку или неправильно понять вывод программы, а также устойчивость системы к злонамеренным действиям.</item>
        <item>В силу своей деятельности, тестировщики занимаются оценкой чужой работы, находят в ней недостатки, что часто воспринимается как деструктивная деятельность, несмотря на то, что ее результатом становится исправление ошибок и улучшение общего качества продукта. Хороший тестировщик должен обладать рядом личных и профессиональных качеств: он должен быть любопытным, критичным, внимательным к деталям, коммуникативным, сохранять профессиональный пессимизм и иметь достаточный опыт для построения предположений о возможных источниках ошибок.</item>
        <item>Тестировщик, в отличие от программиста, главная цель которого – создать работающий продукт, должен уметь найти все заложенные в этом продукте недостатки. А для этого мы должны, прежде всего, сконцентрироваться на том, что может пойти не так. Исследования показали, что, если человек, тестирующий программу, воспринимает ее как  работающую правильно, он найдет меньше ошибок, чем тот, кто будет уверен в наличии в ней множества недостатков.</item>
        <item>Миф о тестировании №1 (Тестирование слишком дорогое). Как говорится: «Не хочешь платить за тестирование в процессе разработки – придется заплатить за тех. поддержку и исправления после релиза». Раннее тестирование помогает сэкономить средства, в то время как отказ или пренебрежение тестированием могут самым печальным образом отразиться на качестве Вашего продукта.</item>
        <item>Миф о тестировании №2 (Тестирование занимает много времени). Само по себе тестирование (при условии грамотной организации производственных процессов) идет параллельно с разработкой, поэтому говорить о затратах времени именно на тестирование можно с натяжкой. Правда в том, что исправление ошибок, найденных в процессе тестирования, требует времени и усилий – но ведь и результатом этих усилий станет повышение качества продукта.</item>
        <item>Миф о тестировании №3 (Тестируются только готовые продукты). Без сомнений, тестирование зависит от написанного кода. Но ведь есть еще тестирование требований и создание тестовых артефактов, которые могут осуществляться и до создания готовой версии продукта. К тому же, в итеративной модели разработки, процессы тестирования и написания программного кода достаточно независимы.</item>
        <item>Миф о тестировании №4 (Можно полностью протестировать программу). Проблема возникает, когда так думает клиент или менеджер проекта. Это утверждение прямо противоречит второму принципу тестирования, поэтому да, Вы, можете провести множество тестов и обеспечить полное покрытие функционала, но это вовсе не будет означать, что ПО протестировано полностью. Всегда может найтись ошибка, которую Вы пропустили. Поэтому исчерпывающее тестирование невозможно – мы можем только довести качество системы до приемлемого уровня.</item>
        <item>Миф о тестировании №5 (В пропущенных багах виноваты тестировщики). Неправильно обвинять тестировщиков в том, что в приложении остаются баги даже после проведения полного цикла тестирования. Проблема здесь в ограничении сроков, стоимости разработки, а также часто меняющихся требованиях. Тестировщики, как и другие участники процесса разработки, зачастую ограничены во времени и ресурсах, что сказывается на качестве их работы. Поэтому здесь нужно определять приоритеты.</item>
        <item>Миф о тестировании №6 (Тестировщики ответственны за качество продукта). Это очень распространенное заблуждение. В обязанности тестировщиков входит нахождение багов и передача информации о них заинтересованным участникам процесса разработки, после чего последние принимают решение о том, что с этими багами дальше делать – будут ли они исправлены или отложены.</item>
        <item>Миф о тестировании №7 (Единственная задача тестировщика – поиск багов). Из предыдущих разделов Вы уже должны были понять что это далеко не так. В то время как разработчики работают, как правило, с достаточно узкой функциональной областью, тестировщики должны понимать организацию системы в целом. Кроме того, в современных условиях тестировщики зачастую принимают участие не только в тестировании как таковом, но и в процессах обеспечения качества.</item>
        <item>Миф о тестировании №8 (Кто угодно может тестировать программное обеспечение). Сегодня, чтобы стать востребованным специалистом в сфере тестирования программного обеспечения, нужно иметь достаточный уровень подготовки, разбираться в современных тенденциях развития информационных технологий и обладать необходимыми для профессии личностными качествами. Хороший тестировщик, кроме непосредственно сферы тестирования, должен знать основы программирования и владеть английским языком на уровне не ниже Intermediate.</item>
        <item>Большинство специалистов сходятся в мысли, что тестирование нужно начинать еще на этапе составления требований к системе. Хотя тут все будет зависеть от выбранной модели разработки. К примеру, в каскадной модели тестирование проводится на специально выделенном для него этапе. Итерационная же модель позволяет осуществлять тестирование практически параллельно с разработкой нового функционала.</item>
        <item>Серия международных стандартов ISO/IEC 25000, также известных как SQuaRE (System and Software Quality Requirements and Evaluation), определяет характеристики, по которым оценивается качество программного продукта. Обновленный стандарт ISO/IEC 25010 содержит терминологию для определения, измерения и оценки качества систем и программных продуктов. Он представляет восемь характеристик качества программного обеспечения, среди которых: функциональная пригодность, уровень производительности, совместимость, удобство использования, надежность, безопасность, удобство сопровождения, портативность.</item>
        <item>Тест-дизайн — один из этапов процесса тестирования, на котором проектируются и создаются тест-кейсы с определёнными ранее целями тестирования. Перед тем, как начать создавать тест-кейсы, мы должны точно понимать, что мы будем тестировать и какие техники тест-дизайна уместны в данном случае при разработке тест-кейсов. Итак, тест-дизайн или разработка тестов — деятельность по получению или выделению тест-кейсов из определённых тестовых условий.</item>
        <item>Тест-кейс пишется для проверки того или иного свойства или поведения программы. К примеру, может ли пользователь зарегистрироваться, используя валидные данные, или нет? Может пользователь авторизоваться в системе после успешной регистрации или нет? Может ли пользователь успешно произвести покупку, авторизуясь под своими учётными данными или нет? И так далее.</item>
        <item>Свойство качественных тест-кейсов №1 (Правильный технический язык, точность и единообразие формулировок). Это свойство должно применяться и к требованиям, и к тест-кейсам, и к отчётам о дефектах — к любой тестовой документации, применяемой на проекте.</item>
        <item>Свойство качественных тест-кейсов №2 (Баланс между специфичностью и общностью). Тест-кейс считается тем более специфичным, чем более детально в нем расписаны действия, конкретные значения и т.д., т.е., чем в нём больше конкретики. Соответственно, тест-кейс считается тем более общим, чем в нём меньше конкретики.</item>
        <item>Свойство качественных тест-кейсов №3 (Баланс между простотой и сложностью). Здесь надо руководствоваться общей логикой при написании тест-кейсов и стараться придерживаться идеи, что простой тест-кейс оперирует одним объектом (или в нём явно виден главный объект), а также содержит небольшое количество тривиальных действий; сложный тест-кейс оперирует несколькими равноправными объектами и содержит много нетривиальных действий.</item>
        <item>Свойство качественных тест-кейсов №4 (Не избыточность по отношению к другим тест-кейсам). Если обнаруживается несколько тест-кейсов, дублирующих задачи друг друга, лучше всего или удалить все, кроме одного, самого показательного, или перед удалением остальных на их основе доработать выбранный самый показательный тест-кейс.</item>
        <item>Свойство качественных тест-кейсов №5 (Возможность повторного использования). Это свойство редко выполняется для низкоуровневых тест-кейсов, но при создании высокоуровневых можно добиться таких формулировок, при которых: A. Тест-кейс будет пригодным к использованию с различными настройками тестируемого приложения и в различных тестовых окружениях. Б. Тест-кейс практически без изменений можно будет использовать для тестирования аналогичной функциональности в других проектах или других областях приложения.</item>
        <item>Свойство качественных тест-кейсов №6 (Повторяемость). Тест-кейс должен быть сформулирован таким образом, чтобы при многократном повторении он показывал одинаковые результаты. Это связано с недвусмысленностью формулировки шагов – специалист, выполняющий тест-кейс, должен точно понимать каждый раз, что необходимо выполнить и в рамках каких условий. Также шаги не должны приводить к последствиям, которые могут привести к затруднению дальнейшего тестирования (например, удалить базу данных).</item>
        <item>Свойство качественных тест-кейсов №7 (Ожидаемый результат для каждого шага тест-кейса). Бывает, встречаются тест-кейсы, в которых ожидаемый результат указывается только после последнего шага. Эта методика написания тест-кейсов снижает их эффективность, поскольку отсутствие результатов для первых шагов не дает чёткого понимания, как должно вести себя приложение или программа при их прохождении.</item>
    </string-array>

    <string name="in_development">В разработке</string>
    <string name="TestGoals">Цели тестирования</string>
    <string name="developmentStages">Стадии цикла разработки ПО</string>
    <string name="vModel">V-модель</string>
    <string name="IterativeModel">Итеративная модель</string>
    <string name="waterfallModel">Каскадная модель</string>
    <string name="integrationTesting">Интеграционное тестирование</string>
    <string name="unitTesting">Модульное тестирование</string>
    <string name="acceptanceTesting">Приемочное тестирование</string>
    <string name="systemTesting">Системное тестирование</string>
    <string name="smokeTesting">Дымное тестирование</string>
    <string name="InternationalizationAndLocalization">Интернационализация и локализация</string>
    <string name="configurationTesting">Конфигурационное тестирование</string>
    <string name="nonFunctionalTesting">Нефункциональное тестирование</string>
    <string name="regressionTesting">Регрессионное тестирование</string>
    <string name="stressTesting">Стресс тестирование</string>
    <string name="securityTesting">Тестирование безопасности</string>
    <string name="interactionTesting">Тестирование взаимодействия</string>
    <string name="documentationTesting">Тестирование документации</string>
    <string name="testingForFailureAndRecovery">Тестирование на отказ и восстановление</string>
    <string name="performanceTesting">Тестирование производительности</string>
    <string name="buildTesting">Тестирование сборки</string>
    <string name="installationTesting">Тестирование установки</string>
    <string name="functionalTesting">Функциональное тестирование</string>
    <string name="usability">Юзабилити</string>
    <string name="staticAndDynamicTesting">Статическое и динамическое тестирование</string>
    <string name="whiteBlackGreyBox">WhiteBlackGrey Box-тестирование</string>


    <string name="verificationAndValidation">Верификация и валидация</string>
    <string name="verificationAndValidationText">    Эти два понятия тесно связаны с процессами тестирования и обеспечения качества. К сожалению, их часто путают, хотя отличия между ними достаточно существенны.</string>
    <string name="verificationAndValidationText1">    Верификация (Verification) — это статическая практика проверки документов, дизайна, архитектуры, кода, т.д.</string>
    <string name="verificationAndValidationText2">    Верификация — это процесс включающий в себя проверку Plans, Requirement Specifications, Design Specifications, Code, Test Cases, Chek-Lists, etc.</string>
    <string name="verificationAndValidationText3">    Верификация всегда проходит без запуска кода.</string>
    <string name="verificationAndValidationText4">    Верификация использует методы — reviews, walkthroughs, inspections, etc.</string>
    <string name="verificationAndValidationText5">    Верификация отвечает на вопрос “Делаем ли мы продукт правильно?”</string>
    <string name="verificationAndValidationText6">    Верификация поможет определить, является ли программное обеспечение высокого качества, но оно не гарантирует, что система полезна.</string>
    <string name="verificationAndValidationText7">    Проверка связана с тем, что система хорошо спроектирована и безошибочна.</string>
    <string name="verificationAndValidationText8">    Верификация происходит до Validation.</string>
    <string name="verificationAndValidationText9">    Она содержит все активности которые позволяют достигнуть высокого качества программного обеспечения.</string>
    <string name="verificationAndValidationText10">    Валидация (validation) – это процесс оценки конечного продукта, необходимо проверить, соответствует ли программное обеспечение ожиданиям и требованиям клиента. Это динамический механизм проверки и тестирования фактического продукта.</string>
    <string name="verificationAndValidationText11">    Валидация всегда включает в себя запуск кода программы.</string>
    <string name="verificationAndValidationText12">    Валидация использует методы, такие как тестирование Black Box, тестирование White Box и нефункциональное тестирование.</string>
    <string name="verificationAndValidationText13">    Валидация отвечает на вопрос “Делаем ли мы правильный продукт?”.</string>
    <string name="verificationAndValidationText14">    Валидация проверяет, соответствует ли программное обеспечение требованиям и ожиданиям клиента.</string>
    <string name="verificationAndValidationText15">    Валидация может найти ошибки, которые процесс Verification не может поймать.</string>
    <string name="verificationAndValidationText16">    Валидация происходит после Verification.</string>
    <string name="verificationAndValidationText17">    На практике, отличия верификации и валидации имеют большое значение: заказчика интересует в большей степени валидация (удовлетворение собственных требований); исполнителя, в свою очередь, волнует не только соблюдение всех норм качества (верификация) при реализации продукта, а и соответствие всех особенностей продукта желаниям заказчика.</string>

    <string name="softwareQuality">Качество ПО (ISO/IEC 25010)</string>
    <string name="softwareQualityText">Серия международных стандартов ISO/IEC 25000, также известных как SQuaRE (System and Software Quality Requirements and Evaluation), определяет характеристики, по которым оценивается качество программного продукта. Обновленный стандарт ISO/IEC 25010 содержит терминологию для определения, измерения и оценки качества систем и программных продуктов. Он представляет восемь характеристик качества программного обеспечения, среди которых:</string>
    <string name="softwareQualityText1">- Функциональная пригодность.</string>
    <string name="softwareQualityText2">- Уровень производительности.</string>
    <string name="softwareQualityText3">- совместимость.</string>
    <string name="softwareQualityText4">- удобство использования.</string>
    <string name="softwareQualityText5">- надежность.</string>
    <string name="softwareQualityText6">- безопасность.</string>
    <string name="softwareQualityText7">- удобство сопровождения.</string>
    <string name="softwareQualityText8">- портативность.</string>
    <string name="softwareQualityText9">- Стандарт ISO/IEC 25010 является серьезным пересмотром стандарта ISO/IEC 9126. В новый стандарт добавлены дополнительные характеристики и подхарактеристики, которые более подробно описывают процесс качества программного продукта, а также введены уточнения и перегруппировка характеристик для более ясного их понимания. Более детально ознакомиться с обновлённым стандартом можно в презентации далее.</string>

    <string name="webTesting">Тестирование веб-проектов</string>
    <string name="webTestingText">Тестирование играет жизненно важную роль в процессе разработки и создания качественного программного обеспечения. Необходимо серьезно относиться к анализу и проектированию структурированного процесса, который обеспечит своевременный и успешный выпуск проекта. Важно помнить, что доверие пользователей очень просто потерять, и исправить совершенные ошибки может стоить дороже, чем изначально произвести полную подготовку и тестирование.</string>
    <string name="webTestingText1">Этапы тестирования веб-проектов:</string>
    <string name="webTestingText2">Подготовительный этап и изучение документации.</string>
    <string name="webTestingText3"> В данный этап входит анализ технического задания; изучение конечных макетов;тест кейсов;матрицы соответствия (для валидации покрытия требований по продукту тестами) и составление плана тестирования.</string>
    <string name="webTestingText4">Тестирование верстки.</string>
    <string name="webTestingText5">Визуальная часть:</string>
    <string name="webTestingText6">неверное отображение блоков, составляющих интерфейса, не состыковки цветовой гаммы;</string>
    <string name="webTestingText7">тестирование локализованных версий (перевод сайта);</string>
    <string name="webTestingText8">соответствие макету (слои в PhotoShop); при уменьшении/увеличении масштабов (75–150%) без визуальных недочетов;</string>
    <string name="webTestingText9">подсвечивание полей с ошибками;</string>
    <string name="webTestingText10">проверка в разрешениях (+прокрутка);</string>
    <string name="webTestingText11">Проверить можно так: FirefoxMenu –> Инструменты –> Веб-разработчик –> Адаптивный дизайн или Resolution Test Plugin в Chrome.</string>
    <string name="webTestingText12">Доступность и отсутствие JS ошибок:</string>
    <string name="webTestingText13">нажимаются ли кликабельные элементы (внутренние/внешние ссылки, ссылки на электронную почту, кнопки, иконки);</string>
    <string name="webTestingText14">при наведении на кликабельные изменяется курсор, иначе – нет; подсказки на непонятных кликабельных элементах;</string>
    <string name="webTestingText15">при отключении изображений должны быть подписи небольшим серым цветом (в Web Developer –> Images –> Replace Image With Alt Attributes);</string>
    <string name="webTestingText16">работоспособность при выключенном JS.</string>
    <string name="webTestingText17">Критические функции должны быть доступны без JS (в Web Developer –> Disable –> Disable JS –> All JS)</string>
    <string name="webTestingText18">Корректная работа, надежная верстка:</string>
    <string name="webTestingText19">проверка работы с данными (введение большого и малого количества текста в форму; блоки с контентом меняются местами (Firebug (HTML –> Edit)));</string>
    <string name="webTestingText20">проверка работы стилей (введение текста с заголовками, с абзацем и без, с картинками).</string>
    <string name="webTestingText21">404-е запросы:</string>
    <string name="webTestingText22">нет ли 404-х ошибок (Firefox –> Tools –> Validate links)</string>
    <string name="webTestingText23">Функциональное тестирование.</string>
    <string name="webTestingText24">Вид тестирования, при котором выявляется некорректная/неправильная работа функционала программы.</string>
    <string name="webTestingText25">Необходимыми проверками являются:</string>
    <string name="webTestingText26">корректность работы главных функций сайта;</string>
    <string name="webTestingText27">переход по ссылкам;</string>
    <string name="webTestingText28">проверка пользовательских форм (валидация полей, обязательные/необязательные поля, уведомления об ошибках при неверном вводе, добавление комментариев в блог, обратная связь);</string>
    <string name="webTestingText29">поиск и покупка товара, оформление заказа;</string>
    <string name="webTestingText30">сверка переданного заказчиком контента с имеющимся на сайте;</string>
    <string name="webTestingText31">проверка возможной авторизации/регистрации;</string>
    <string name="webTestingText32">добавление, удаление и редактирование данных пользователей, товаров и заказов.</string>
    <string name="webTestingText33">Ad-hock тестирование — импровизационное тестирование без подготовки.</string>
    <string name="webTestingText34">Помогает понять:</string>
    <string name="webTestingText35">понятно ли назначение форм;</string>
    <string name="webTestingText36">отмечены ли обязательные поля и все ли обязательные поля отмечены;</string>
    <string name="webTestingText37">встроена ли обязательная проверка заполненных форм;</string>
    <string name="webTestingText38">происходит ли проверка правильности ввода контактных данных.</string>
    <string name="webTestingText39">Из достоинств данного тестирования можно выделить:</string>
    <string name="webTestingText40">достаточно быстрое знакомство с системой;</string>
    <string name="webTestingText41">специфические неисправности;</string>
    <string name="webTestingText42">массу вопросов и предложений;</string>
    <string name="webTestingText43">экономию времени.</string>
    <string name="webTestingText44">Негативное тестирование, обычно называемое тестированием пути ошибок или тестированием на сбой, это процесс применения как можно большего количества креативных подходов и проверки приложения на предмет неверных данных. Его предназначение состоит в том, чтобы проверить, показываются ли ошибки пользователю, где они могут быть, или обрабатывать неправильные значения более изящно. Проводится для обеспечения стабильности приложения.</string>
    <string name="webTestingText45">Эквивалентные тесты – это тесты, которые приводят к одному и тому же результату.</string>
    <string name="webTestingText46">Группа тестов представляет собой класс эквивалентности, при выполнении следующих условий:</string>
    <string name="webTestingText47">все тесты написаны для выявления одной ошибки;</string>
    <string name="webTestingText48">если один из тестов выявит ошибку, то остальные тоже ее выявят; обратное тоже верно.</string>
    <string name="webTestingText49">Эквивалентная область – часть области входных или выходных данных, для которых поведение компонентов или систем, основываясь на спецификации, считаются одинаковыми.</string>
    <string name="webTestingText50"> Exploratory testing, также называется интуитивным тестированием, подразумевает под собой одновременно проектирование, выполнение тестов и обучение продукту.</string>
    <string name="webTestingText51">Usability тестирование (User Experience).</string>
    <string name="webTestingText52">Позволяет проверить комфортное использование сайта для пользователя, насколько легко найти необходимую информацию или выполнить желаемые действия.</string>
    <string name="webTestingText53">Навигационное тестирование сайта.</string>
    <string name="webTestingText54">Все ли страницы, кнопки и поля на них, понятны в использовании, доступ к главной странице и меню со всех остальных страниц возможен, навигация проста и интуитивно понятна.</string>
    <string name="webTestingText55">Тестирование контента.</string>
    <string name="webTestingText56">Отсутствие грамматических/орфографических ошибок, контент информативен и структурированный, изображения и заголовки имеют подходящие размеры и размещены правильно.</string>
    <string name="webTestingText57">Удобство использования.</string>
    <string name="webTestingText58">Понятна ли структура веб-приложения, какое впечатление производит и есть ли лишние компоненты на страницах.</string>
    <string name="webTestingText59">Тестирование UI (User Interface).</string>
    <string name="webTestingText60">Соответствие стандартам графических интерфейсов и элементов дизайна, правильность локализованных версий, тестирования с различными разрешениями, на смартфонах и планшетах.</string>
    <string name="webTestingText61">Тестирование совместимости (конфигурационное тестирование).</string>
    <string name="webTestingText62">Тип нефункционального тестирования программного обеспечения, позволяющий проверить, может ли ПО работать на другом оборудовании, операционных системах, приложениях, сетевых средах или мобильных устройствах.</string>
    <string name="webTestingText63">Кросс-платформенное тестирование сайта.</string>
    <string name="webTestingText64">Некоторые функции могут иметь проблемы с определенными операционными системами, поэтому необходимо проверять работу приложения в различных версиях Windows, Unix, Mac, Linux, Solaris и др.</string>
    <string name="webTestingText65">Кросс-браузерное тестирование сайта.</string>
    <string name="webTestingText66">Также корректная работа зависит от типа браузера. Верстка должна быть кроссбраузерной, чтобы обеспечить одинаковую визуальную часть, доступность, функциональность и дизайн во всех браузерах. Необходимо проверять масштабируемость, расширяемость, рамки для элементов в фокусе, отсутствие JS ошибок (левый нижний угол страницы). Проверять работу необходимо в таких браузерах, как: Internet Explorer, Firefox, Chrome, Safari, Opera, Edge разных версий.</string>
    <string name="webTestingText67">Просмотр на мобильных устройствах.</string>
    <string name="webTestingText68">Несмотря на проверку работы веб-приложений в различных разрешениях на компьютере, зачастую ошибки на мобильных устройствах остаются не замечены. Следовательно, настоятельно рекомендуется проверять корректное отображение и работу вашего веб-приложения на мобильных устройствах разных операционных устройств, а также на планшетах.</string>
    <string name="webTestingText69">Тестирование БД.</string>
    <string name="webTestingText70">Необходимо проверить правильность осуществления связи с сервером, проверить совместимость сервера с ПО, аппаратными средствами, базой данных и сетью. Также нужно проверить что происходит при прерывании какого-либо действия, при повторном подключении к серверу во время выполнения операций.</string>
    <string name="webTestingText71">Тестирование производительности.</string>
    <string name="webTestingText72">Методика нефункционального тестирования, для измерения таких параметров системы как отзывчивость и стабильность, при различных нагрузках. Позволяет исследовать скорость быстродействия сайта и возможности масштабируемости приложения, например, при добавлении новых пользователей. Проводится с целью выяснить какую нагрузку сайт способен выдержать. Тестирование производительности измеряет атрибуты качества системы, такие как масштабируемость, надежность и использование ресурсов.</string>
    <string name="webTestingText73">Нагрузочное тестирование – это метод тестирования производительности, при котором реакция системы измеряется в различных условиях нагрузки. Отвечает за реакцию веб-приложения при увеличении рабочей нагрузки. Нагрузочные испытания проводятся для нормальных и пиковых нагрузок (одновременная покупка товара или авторизация на сайте большого количества пользователей).</string>
    <string name="webTestingText74">Подход нагрузочного тестирования:</string>
    <string name="webTestingText75">Оценить критерии приемлемости производительности,</string>
    <string name="webTestingText76">Определить критические сценарии,</string>
    <string name="webTestingText77">Модель рабочей нагрузки,</string>
    <string name="webTestingText78">Определите целевые уровни нагрузки,</string>
    <string name="webTestingText79">Дизайн тестов,</string>
    <string name="webTestingText80">Выполнить тесты,</string>
    <string name="webTestingText81">Проанализируйте результаты,</string>
    <string name="webTestingText82">Задачи нагрузочного тестирования:</string>
    <string name="webTestingText83">время отклика,</string>
    <string name="webTestingText84">пропускная способность,</string>
    <string name="webTestingText85">утилизация ресурсов,</string>
    <string name="webTestingText86">максимальная пользовательская нагрузка,</string>
    <string name="webTestingText87">бизнес-метрики.</string>
    <string name="webTestingText88">Стресс-тестирование (Stress Testing) проверяет систему на ее устойчивость и обработку ошибок в условиях чрезвычайно высокой нагрузки (оценивает как система работает в экстремальных условиях, за пределами ограничений и лимитов).</string>
    <string name="webTestingText89">Стресс-тестирование проводится, чтобы убедиться, что система не будет аварийно завершать работу в критических ситуациях.</string>
    <string name="webTestingText90">Тестирование стабильности/надежности (Stability/Reliability Testing) – тип тестирования программного обеспечения, который проверяет, может ли программное обеспечение выполнять безотказную работу в течение определенного периода времени в указанной среде.</string>
    <string name="webTestingText91">Объемное тестирование (Volume Testing) – тип тестирования программного обеспечения, проводится для анализа производительности системы за счет увеличения объема данных в базе данных.</string>
    <string name="webTestingText92">Тестирование параллелизма (Parallel Testing) – тип тестирования программного обеспечения, который проверяет несколько приложений или подкомпонентов одного приложения одновременно, чтобы сократить время тестирования.При параллельном тестировании тестировщик запускает две разные версии программного обеспечения одновременно с одним и тем же вводом.Цель состоит в том, чтобы выяснить, ведут ли себя прежняя система и новая система одинаково или по-разному.</string>
    <string name="webTestingText93">Тестирование безопасности.</string>
    <string name="webTestingText94">Направлено на оптимизацию безопасности системы при проектировании, разработке, использовании и обслуживании программных систем и их интеграции с критически важными для безопасности аппаратными системами в производственной среде.</string>
    <string name="webTestingText95">Аспекты безопасности программного обеспечения:</string>
    <string name="webTestingText96">Функциональное программное обеспечение не должно создавать опасностей (например: управление современным самолетом НЕ должно направляться в океан).</string>
    <string name="webTestingText97">Системы мониторинга должны работать без сбоев (например: резервный компьютер должен запускаться автоматически при сбое основного).</string>
    <string name="webTestingText98">Цели в тестировании безопасности:</string>
    <string name="webTestingText99">в сложных системах, где задействовано много взаимодействий, критически важные для безопасности функции должны быть идентифицированы и тщательно проанализированы;</string>
    <string name="webTestingText100">ошибки определены и устранены;</string>
    <string name="webTestingText101">количество критических ошибок поддерживается на низком уровне, чтобы избежать неработоспособности системы;</string>
    <string name="webTestingText102">атрибуты безопасности должны рассматриваться как часть всех уровней тестирования ПО.</string>
    <string name="webTestingText103">Принципы безопасности:</string>
    <string name="webTestingText104">Конфиденциальность (ограничение или предоставление доступа к информации).</string>
    <string name="webTestingText105">Целостность (возможность восстановить данные в полном объеме при их повреждении; доступ на изменение информации только определенной категории пользователей).</string>
    <string name="webTestingText106">Доступность (иерархия уровней доступа и четкое их соблюдение).</string>
    <string name="webTestingText107">Обработка ошибок и регрессионное тестирование.</string>
    <string name="webTestingText108">После завершения разработки веб-приложения следует провести оценку и анализ выявленных ошибок для дальнейшего предотвращение их повтора. А также выполнить регрессионное тестирование.</string>
    <string name="webTestingText109">Регрессионное тестирование.</string>
    <string name="webTestingText110">Использует технику тестирования черного ящика (повторное выполнение тестов), на которые влияют изменения кода. Эти тесты должны выполняться как можно чаще в течение всего ЖЦПО при изменениях кода для исправления дефектов или для улучшения работы веб-приложения.</string>
    <string name="webTestingText111">Практические советы вам:</string>
    <string name="webTestingText112">Перед тем, как приступить к тестированию необходимо обсудить все важные детали с командой (BA, PM, разработчики).</string>
    <string name="webTestingText113">Использовать обширный подход с применением техник тест-анализа и набора методик тест-дизайна.</string>
    <string name="webTestingText114">Определить виды тестирования, которые необходимо провести.</string>
    <string name="webTestingText115">Определить цели и ключевых пользователей веб-приложения.</string>
    <string name="webTestingText116">Списки устройств, ОС и браузеров, на которых необходимо провести тестирование.</string>
    <string name="webTestingText117">Доступ для разных ролей посетителей.</string>
    <string name="webTestingText118">Необходимость составления и передачи документации.</string>
    <string name="webTestingText119">Хотим вам напомнить, что рабочий процесс – это не рутина, а творческий процесс, определяющий широту полета вашей мысли. Относитесь к вашей работе как к новому челленджу, и вы определенно начнете получать не только удовольствие, но и вдохновение и желание развиваться. Задачи тестировщика очень многогранны: им необходимо понять задачу веб-приложения, понять как оно должно работать, какие задачи решать, какую пользу приносить пользователям и затем перепроверить все по несколько раз, чтобы выпустить проект в мир. Им нужно быть собранными и дерзать, чтобы выпускать проекты за которые вся команда сможет гордиться.</string>

    <string name="roleOfTesting">Роль тестирования</string>
    <string name="roleOfTestingText">Как видим, человеческие ошибки могут приводить к появлению дефектов на всех стадиях разработки программного продукта, причем последствия этого могут быть самыми разными – от незначительных до катастрофических. Тестирование позволяет находить и исправлять дефекты, тем самым снижая уровень риска и повышая качество продукта. Проверяются, в том числе, и места пользовательского интерфейса, где пользователь может сделать ошибку или неправильно понять вывод программы, а также устойчивость системы к злонамеренным действиям. Почему важен процесс тестирования?</string>
    <string name="roleOfTestingText1">– Процесс разработки ПО невозможен без контроля качества разрабатываемого продукта;</string>
    <string name="roleOfTestingText2">– Процесс тестирования ПО представляет собой столь же неотъемлемую часть процесса разработки, как и проектирование;</string>
    <string name="roleOfTestingText3">– Тестирование позволяет оценить качество разрабатываемого продукта.</string>

    <string name="whyTestingIsNecessary">Почему тестирование необходимо</string>
    <string name="whyTestingIsNecessaryText">В этом разделе мы рассмотрим самые базовые понятия и принципы, которые используются в процессе тестирования. Мы узнаем, что же, собственно, собой представляет тестирование, зачем оно нужно и кто им занимается. Рассмотрим цели, принципы и основные этапы тестирования. Почувствуем, каким должен быть психологический настрой настоящего тестировщика и развенчаем напоследок несколько мифов о тестировании. Уверены, Вам будет интересно.</string>
    <string name="whyTestingIsNecessaryText1">Начнем с того, что же такое «тестирование». Для начала, давайте абстрагируемся от сухих академических определений и посмотрим на это понятие с точки зрения повседневного использования. Когда мы что-то тестируем, то задаем себе простой вопрос: «работает ли это так, как мы ожидаем?» или, другими словами: соответствует ли реальное поведение объекта тестирования нашим ожиданиям? Если ответ положительный – замечательно, если нет, – мы обмануты в своих ожиданиях, а значит что-то нужно исправлять. Тестирование необходимо потому, что все мы совершаем ошибки. Некоторые из них могут быть незначительными, в то время как другие – иметь самые разрушительные последствия. Все, что производится человеком, может содержать ошибки (так уж мы, люди, устроены). Именно поэтому любой продукт нуждается в проверке – тестировании, прежде чем его можно будет эффективно и безопасно использовать. То же самое справедливо и для программного обеспечения (англ. Software).</string>
    <string name="whyTestingIsNecessaryText2">Программное обеспечение (Software) – компьютерные программы, функции, а также сопровождающая их документация и данные, имеющие отношение к эксплуатации компьютерной системы. Компьютерные технологии все глубже проникают в нашу повседневную жизнь. Программное обеспечение управляет работой множества окружающих нас вещей – от мобильных телефонов и компьютеров до стиральных машин и кредитных карт. В любом случае, все мы сталкивались с теми или иными ошибками в программах: текстовый редактор, намертво зависший при работе над дипломным проектом, банкомат, «съевший» карточку или просто сайт, который никак не загрузится – все это отнюдь не облегчает нам жизнь. Однако не все ошибки одинаково опасны – для разных программных систем уровни риска могут отличаться. Риск (risk):</string>
    <string name="whyTestingIsNecessaryText3">– фактор, который может привести к негативным последствиям в будущем; как правило, выражается через вероятность наступления таких последствий и их влияние на систему.</string>
    <string name="whyTestingIsNecessaryText4">– то, что еще не произошло, и может вообще не произойти; потенциальная проблема.</string>
    <string name="whyTestingIsNecessaryText5">Кроме того, уровень риска будет зависеть от вероятности наступления негативных последствий. К примеру, одна и та же незначительная ошибка, скажем опечатка, может иметь совершенно разные уровни риска для разных программ:</string>
    <string name="whyTestingIsNecessaryText6">– опечатка в описании интересов на персональной страничке в социальной сети вряд ли будет иметь существенные последствия, разве что вызовет улыбку у Ваших друзей;</string>
    <string name="whyTestingIsNecessaryText7">– такая же простая опечатка, допущенная в описании деятельности крупной компании, размещенном на ее сайте, уже опасна, так как косвенно свидетельствует о непрофессионализме ее сотрудников;</string>
    <string name="whyTestingIsNecessaryText8">– опечатка в коде программы, которая подсчитывает уровни облучения при работе рентгеновского аппарата (например, 100 вместо 10) может иметь самые печальные последствия – вред, нанесенный здоровью и безопасности людей, выльется в потерю доверия к компании и судебные иски со многими нулями.</string>

    <string name="WhatIsSoftwareTesting">Что такое тестирование ПО</string>
    <string name="WhatIsSoftwareTestingText">Выше мы рассмотрели примеры того, зачем тестирование необходимо, но пока так и не дали ему четкого определения. Что ж, пора исправиться.</string>
    <string name="WhatIsSoftwareTestingText1">Тестирование программного обеспечения – это:</string>
    <string name="WhatIsSoftwareTestingText2">– процесс исследования ПО с целью получения информации о качестве продукта;</string>
    <string name="WhatIsSoftwareTestingText3">– процесс проверки соответствия заявленных к продукту требований и реально реализованной функциональности, осуществляемый путем наблюдения за его работой в искусственно созданных ситуациях и на ограниченном наборе тестов, выбранных определенным образом;</string>
    <string name="WhatIsSoftwareTestingText4">– оценка системы с тем, чтобы найти различия между тем, какой система должна быть и какой она есть.</string>
    <string name="WhatIsSoftwareTestingText5">В широком смысле, тестирование – это одна из техник контроля качества (Quality Control), которая включает планирование, составление тестов, непосредственно выполнение тестирования и анализ полученных результатов.Важно понимать, что тестирование ПО включает не только собственно проведение тестов, но и многие другие действия, связанные с процессом обеспечения качества:</string>
    <string name="WhatIsSoftwareTestingText6">– анализ и планирование;</string>
    <string name="WhatIsSoftwareTestingText7">– разработку тестовых сценариев;</string>
    <string name="WhatIsSoftwareTestingText8">– оценку критериев окончания тестирования;</string>
    <string name="WhatIsSoftwareTestingText9">– написание отчетов;</string>
    <string name="WhatIsSoftwareTestingText10">– рецензирование документации (в том числе и исходного кода);</string>
    <string name="WhatIsSoftwareTestingText11">– проведение статического анализа.</string>

    <string name="WhoIsTesting">Кто занимается тестированием</string>
    <string name="WhoIsTestingText">Все зависит от организации процесса и его участников. В IT-индустрии большие компании, как правило, имеют команду специалистов, ответственных за оценку соответствия продукта установленным заказчиком требованиям. То есть, отдел качества. Более того, сами разработчики тоже проводят тестирование, которое называется модульным. Модульное тестирование (Unit testing) – тестирование отдельных компонентов программной системы. В роли таких компонентов обычно выступают функции или классы. В большинстве случаев, в процесс тестирования вовлечены такие специалисты:</string>
    <string name="WhoIsTestingText1">— Тестировщик ПО (Software tester);</string>
    <string name="WhoIsTestingText2">— Разработчик ПО (Software developer);</string>
    <string name="WhoIsTestingText3">— Менеджер проекта (Project manager);</string>
    <string name="WhoIsTestingText4">— Заказчик (Product owner);</string>
    <string name="WhoIsTestingText5">— Конечный пользователь (End user).</string>
    <string name="WhoIsTestingText6">В разных компаниях приняты разные обозначения специальности людей, которые занимаются тестированием: тестировщик, специалист по обеспечению качества программного обеспечения (Software Quality Assurance engineer), тест-аналитик (QA analyst) и т.д.</string>

    <string name="startAndExit">Когда начинать и заканчивать тестирование</string>
    <string name="startAndExitText">Вспомним график стоимости дефектов:</string>
    <string name="startAndExitText1">ФОТО</string>
    <string name="startAndExitText2"> Как видим, чем позже дефект был обнаружен, тем дороже обойдется его исправление и тем больше усилий для этого потребуется. Кроме того, как мы помним, дефекты, заложенные в систему на ранних уровнях проектирования особенно коварны – их трудно отследить и правильно интерпретировать. Вывод напрашивается сам собой: чем раньше в жизненном цикле программы начнется тестирование, тем в большей степени мы можем быть уверены в ее качестве.</string>
    <string name="startAndExitText3">Большинство специалистов сходятся в мысли, что тестирование нужно начинать еще на этапе составления требований к системе. Хотя тут все будет зависеть от выбранной модели разработки (о них мы поговорим чуть позже). К примеру, в каскадной модели тестирование проводится на специально выделенном для него этапе. Итерационная же модель позволяет осуществлять тестирование практически параллельно с разработкой нового функционала. На разных этапах жизненного цикла ПО тестирование проводится в разных формах:</string>
    <string name="startAndExitText4">– на этапе определения требований: их анализ и верификация также могут считаться тестированием;</string>
    <string name="startAndExitText5">– контроль процесса проектирования на этапе разработки дизайна системы – это тоже форма тестирования;</string>
    <string name="startAndExitText6">– как уже упоминалось, разработчики тоже участвуют в тестировании на уровне модульного тестирования.</string>
    <string name="startAndExitText7">Труднее определить критерий окончания тестирования, поскольку, согласно принципам тестирования, мы никогда не можем быть уверены в том, что программа на 100% свободна от дефектов. Поэтому используются другие условия:</string>
    <string name="startAndExitText8">1. граничные сроки, установленные заранее;</string>
    <string name="startAndExitText9">2. выполнение всех предусмотренных тест-кейсов;</string>
    <string name="startAndExitText10">3. достижение определенного уровня тестового покрытия;</string>
    <string name="startAndExitText11">4. когда после определенного момента, мы практически не находим новых багов или критических дефектов;</string>
    <string name="startAndExitText12">5. решение менеджмента.</string>

    <string name="testGoals">Цели тестирования</string>
    <string name="testGoalsText">Можно определить такие основные цели тестирования программного обеспечения:</string>
    <string name="testGoalsText1">– Предоставление информации о качестве ПО конечному заказчику;</string>
    <string name="testGoalsText2">– Повышение качества ПО;</string>
    <string name="testGoalsText3">– Предотвращение появления дефектов.</string>
    <string name="testGoalsText4">Цели тестирования могут отличаться, в зависимости от этапа разработки ПО, на котором оно проводится. К примеру, на этапе кодирования целью тестирования будет вызов как можно большего количества сбоев в работе программы, что позволит локализовать и исправить дефекты. В то же время, при приемочном тестировании необходимо показать, что система работает правильно. В период сопровождения, тестирование в основном необходимо для того, чтобы убедится в отсутствии новых багов, появившихся во время внесения изменений. Главная же задача тестирования – поиск дефектов.</string>

    <string name="WhereDoErrorsComeFrom">Откуда берутся ошибки</string>
    <string name="WhereDoErrorsComeFromText">Почему бывает так, что программы работают неправильно? Все очень просто – они создаются и используются людьми. Если пользователь допустит ошибку, это может привести к проблеме в работе программы – она используется неправильно, а значит, может повести себя не так, как ожидалось.</string>
    <string name="WhereDoErrorsComeFromText1">Ошибка (error) – это действие человека, которое порождает неправильный результат. Однако программы разрабатываются и создаются людьми, которые также могут допускать (и допускают) ошибки. Это значит, что недостатки есть и в самом программном обеспечении. Они называются дефектами или багами (оба обозначения равносильны). Здесь важно помнить, что программное обеспечение – нечто большее, чем просто код.</string>
    <string name="WhereDoErrorsComeFromText2">Дефект, Баг (Defect, Bug) – недостаток компонента или системы, который может привести к отказу определенной функциональности. Дефект, обнаруженный во время исполнения программы, может вызвать отказ отдельного компонента или всей системы. При исполнении кода программы дефекты, заложенные еще во время его написания, могут проявиться: программа может не делать того, что должна или наоборот – делать то, чего не должна, – происходит сбой.</string>
    <string name="WhereDoErrorsComeFromText3"> Сбой (failure) – несоответствие фактического результата (actualresult) работы компонента или системы ожидаемому результату (expectedresult). Сбой в работе программы может являться индикатором наличия в ней дефекта. Таким образом, баг существует при одновременном выполнении трех условий:</string>
    <string name="WhereDoErrorsComeFromText4">известен ожидаемый результат;</string>
    <string name="WhereDoErrorsComeFromText5">известен фактический результат;</string>
    <string name="WhereDoErrorsComeFromText6">фактический результат отличается от ожидаемого результата.</string>
    <string name="WhereDoErrorsComeFromText7">Важно понимать, что не все баги становятся причиной сбоев – некоторые из них могут никак себя не проявлять и оставаться незамеченными (или проявляться только при очень специфических обстоятельствах). Причиной сбоев могут быть не только дефекты, но также и условия окружающей среды: например, радиация, электромагнитные поля или загрязнение также могут влиять на работу как программного, так и аппаратного обеспечения. Всего существует несколько источников дефектов и, соответственно, сбоев:</string>
    <string name="WhereDoErrorsComeFromText8">ошибки в спецификации, дизайне или реализации программной системы;</string>
    <string name="WhereDoErrorsComeFromText9">ошибки использования системы;</string>
    <string name="WhereDoErrorsComeFromText10">неблагоприятные условия окружающей среды;</string>
    <string name="WhereDoErrorsComeFromText11">умышленное причинение вреда;</string>
    <string name="WhereDoErrorsComeFromText12">потенциальные последствия предыдущих ошибок, условий или умышленных действий.</string>
    <string name="WhereDoErrorsComeFromText13"> Дефекты могут возникать на разных уровнях, и от того, будут ли они исправлены и когда, будет напрямую зависеть качество системы.</string>
    <string name="WhereDoErrorsComeFromText14">Качество (Quality) – степень, в которой совокупность присущих характеристик соответствует требованиям. Качество программного обеспечения (Software Quality) – это совокупность характеристик программного обеспечения, отражающих его способность удовлетворять установленные и предполагаемые потребности. Требование (Requirement) – потребность или ожидание, которое установлено. Обычно предполагается или является обязательным.</string>
    <string name="WhereDoErrorsComeFromText15">ФОТО</string>
    <string name="WhereDoErrorsComeFromText16">В первом случае все было сделано правильно и мы получили продукт, полностью соответствующий ожиданиям заказчика и удовлетворяющий критериям качества.</string>
    <string name="WhereDoErrorsComeFromText17">Во втором случае ошибки были допущены уже при кодировании, что привело к появлению дефектов в готовом продукте. Но на этом уровне баги достаточно легко обнаружить и исправить, поскольку мы видим несоответствие требованиям.</string>
    <string name="WhereDoErrorsComeFromText18">Третий вариант хуже – здесь ошибки были допущены на этапе проектирования системы. Заметить это можно лишь проведя тщательную сверку со спецификацией. Исправить такие дефекты тоже непросто – нужно заново перерабатывать дизайн продукта.</string>
    <string name="WhereDoErrorsComeFromText19">В четвертом случае дефекты были заложены еще на этапе формирования требований; вся дальнейшая разработка и даже тестирование пошли по изначально неправильному пути. Во время тестирования мы не найдем багов – программа пройдет все тесты, но может быть забракована заказчиком.</string>
    <string name="WhereDoErrorsComeFromText20">Условно, можно выделить пять причин появления дефектов в программном коде.</string>
    <string name="WhereDoErrorsComeFromText21">1. Недостаток или отсутствие общения в команде. Зачастую, бизнес требования просто не доходят до команды разработки. У заказчика есть понимание того, каким он хочет видеть готовый продукт, но если должным образом не объяснить его идею разработчикам и тестировщикам, результат может оказаться не таким, как предполагалось. Требования должны быть доступны и понятны всем участникам процесса разработки ПО.</string>
    <string name="WhereDoErrorsComeFromText22">2. Сложность программного обеспечения. Современное ПО состоит из множества компонентов, которые объединяются в сложные программные системы. Многопоточные приложения, клиент-серверная и распределенная архитектура, многоуровневые базы данных – программы становятся все сложнее в написании и поддержке, и тем труднее становится работа программистов. А чем труднее работа, тем больше ошибок может допустить исполняющий ее человек.</string>
    <string name="WhereDoErrorsComeFromText23">3. Изменения требований. Даже незначительные изменения требований на поздних этапах разработки требуют большого объема работ по внесению изменений в систему. Меняется дизайн и архитектура приложения, что, в свою очередь, требует внесения изменений в исходный код и принципы взаимодействия программных модулей. Такие текущие изменения зачастую становятся источником трудноуловимых дефектов. Тем не менее, часто меняющиеся требования в современном бизнесе – скорее правило, чем исключение, поэтому непрерывное тестирование и контроль рисков в таких условиях – прямая обязанность специалистов отдела обеспечения качества.</string>
    <string name="WhereDoErrorsComeFromText24">4. Плохо документированный код. Сложно поддерживать и изменять плохо написанный и слабо документированный программный код. Во многих компаниях существуют специальные правила по написанию и документированию кода программистами. Хотя на практике часто бывает так, что разработчики вынуждены писать программы в первую очередь быстро и это сказывается на качестве продукта.</string>
    <string name="WhereDoErrorsComeFromText25">5. Средства разработки ПО. Средства визуализации, библиотеки, компиляторы, генераторы скриптов и другие вспомогательные инструменты разработки – это тоже зачастую плохо работающие и слабо документированные программы, которые могут стать источником дефектов в готовом продукте.</string>

    <string name="costOfDefects">Сколько стоят дефекты</string>
    <string name="costOfDefectsText">Здесь все просто: чем раньше мы найдем дефект, тем дешевле нам обойдется его исправление. Понятно, что исправить строчку в спецификации или коде проще и дешевле, чем вносить изменения в готовый продукт. Не говоря уже о ситуации, когда дефект находит заказчик или конечный пользователь – здесь может пострадать репутация компании-разработчика, а такие убытки с трудом поддаются подсчету. Общую тенденцию отображает график:</string>
    <string name="costOfDefectsText1">ФОТО</string>
    <string name="costOfDefectsText2">Со временем, стоимость исправлений возрастает, в то время как влияние участников проекта на процесс разработки постепенно уменьшается. В крайнем случае, если серьезный дефект обнаруживается на поздних этапах разработки, он может остаться неисправленным, поскольку стоимость внесения изменений может оказаться слишком высокой. Кроме того, даже если готовая программа будет соответствовать спецификации, заказчик все равно может отказаться ее принимать, если сама спецификация была неправильной. Проектная команда могла разработать в точности то, что было описано в требованиях, но если требования были истолкованы неправильно, заказчика результат не устроит.</string>

    <string name="fundamentalProcess">Фундаментальный процесс тестирования</string>
    <string name="fundamentalProcessText">Как мы увидели, исполнение тестов необходимо, но не менее важны и сопровождающие действия – планирование и документирование процесса. В обязанности тестировщиков входит разработка тестовых сценариев, а также подготовка тестирования и оценка его результатов. Становление идеи фундаментального тестового процесса на всех уровнях тестирования заняло годы. В рамках этого процесса можно выделить ключевые шаги:</string>
    <string name="fundamentalProcessText1">– планирование и управление;</string>
    <string name="fundamentalProcessText2">– анализ и проектирование;</string>
    <string name="fundamentalProcessText3">– внедрение и реализация;</string>
    <string name="fundamentalProcessText4">– оценка критериев выхода и написание отчетов;</string>
    <string name="fundamentalProcessText5">– действия по завершению тестирования.</string>
    <string name="fundamentalProcessText6">Здесь действия описаны в логической последовательности, но в условиях реального проекта они могут накладываться, происходить одновременно или даже повторяться. Обычно, происходит адаптация этих шагов под нужды конкретной системы или проекта. Рассмотрим их.</string>
    <string name="fundamentalProcessText7">1. Планирование и управление.</string>
    <string name="fundamentalProcessText8">Планирование тестирования включает действия, направленные на определение основных целей тестирования и задач, выполнение которых необходимо для достижения этих целей. В процессе планирования мы убеждаемся в том, что мы правильно поняли цели и пожелания заказчика и объективно оценили уровень риска для проекта, после чего ставим цели и задачи для, собственно, тестирования. Для более ясного описания целей и задач тестирования составляются такие документы как тест-политика, тест-стратегия и тест-план.</string>
    <string name="fundamentalProcessText9">Тест-политика – высокоуровневый документ, описывающий принципы, подходы и основные цели компании в сфере тестирования.</string>
    <string name="fundamentalProcessText10">Тест-стратегия – высокоуровневый документ, содержащий описание уровней тестирования и подходов к тестированию в пределах этих уровней.Действует на уровне компании или программы (одного или больше проектов).</string>
    <string name="fundamentalProcessText11">Тест-план – документ, описывающий средства, подходы, график работ и ресурсы, необходимые для проведения тестирования. Помимо прочего, определяет инструменты тестирования, функциональность, которую требуется протестировать, распределение ролей в команде, тестовое окружение, используемые техники тест-дизайна, критерии начала и окончания тестирования и риски. То есть, это подробное описание всего процесса тестирования.</string>
    <string name="fundamentalProcessText12">В любой деятельности, управление не заканчивается планированием. Нам нужно контролировать и измерять прогресс. Именно поэтому управление тестированием – непрерывный процесс. Управление тестированием – сопоставление текущей ситуации в процессе тестирования с планом и составление отчетности. В свою очередь, данные, полученные в ходе контроля над процессом, учитываются при планировании дальнейших действий.</string>
    <string name="fundamentalProcessText13">2. Анализ и проектирование.</string>
    <string name="fundamentalProcessText14">Анализ и проектирование тестов – это процесс написания тестовых сценариев и условий на основе общих целей тестирования. В процессе анализа и проектирования мы разрабатываем тестовые сценарии на основании общих целей тестирования, определенных во время планирования. </string>
    <string name="fundamentalProcessText15">Тестовый сценарий – документ, определяющий установленную последовательность действий при выполнении тестирования.</string>
    <string name="fundamentalProcessText16">3. Внедрение и реализация.</string>
    <string name="fundamentalProcessText17">Во время выполнения тестирования происходит написание тест-кейсов, на основе написанных ранее тестовых сценариев, собирается необходимая для проведения тестов информация, подготавливается тестовое окружение и запускаются тесты. Тест-кейс – документ, содержащий набор входных значений, пред- и постусловий, а также ожидаемый результат проведения теста, разработанный для проверки соответствия определенной функциональности системы заданным для этой функциональности требованиям. Тестовое окружение – аппаратное и программное обеспечение и другие средства, необходимые для выполнения тестов.</string>
    <string name="fundamentalProcessText18">4. Оценка критериев выхода и написание отчетов.</string>
    <string name="fundamentalProcessText19"> Критерии выхода определяют, когда можно завершать тестирование. Они необходимы для каждого уровня тестирования, поскольку нам необходимо знать, достаточно ли было проведено тестов.</string>
    <string name="fundamentalProcessText20">При оценке критериев выхода необходимо:</string>
    <string name="fundamentalProcessText21">– проверить, было ли проведено достаточное количество тестов, достигнута ли нужная степень обеспечения качества системы.</string>
    <string name="fundamentalProcessText22">– убедится в том, что нет необходимости проводить дополнительные тесты. Если все же такая необходимость есть, возможно, потребуется изменить установленный критерий выхода.</string>
    <string name="fundamentalProcessText23">После окончания тестирования происходит написание отчета, который будет доступен всем заинтересованным сторонам.Ведь не только тестировщики должны знать результаты выполнения тестов, – эта информация может быть необходима многим участникам процесса создания ПО.</string>
    <string name="fundamentalProcessText24">5. Действия по завершению тестирования.</string>
    <string name="fundamentalProcessText25">При завершении тестирования мы собираем, систематизируем и анализируем информацию о его результатах.Она может пригодиться позже – при выпуске готового продукта. Могут быть и другие причины для сворачивания тестирования, например, досрочное закрытие проекта или завершение определенного этапа разработки.</string>
    <string name="fundamentalProcessText26">Основные цели этого этапа:</string>
    <string name="fundamentalProcessText27">– убедиться, что вся запланированная функциональность действительно была реализована;</string>
    <string name="fundamentalProcessText28">– проверить, что все отчеты об ошибках, поданные ранее, были, так или иначе, закрыты;</string>
    <string name="fundamentalProcessText29">– завершение работы тестового обеспечения, тестового окружения и инфраструктуры;</string>
    <string name="fundamentalProcessText30">– оценить общие результаты тестирования и проанализировать опыт, полученный в его процессе.</string>

    <string name="TestingPrinciples">Принципы тестирования</string>
    <string name="TestingPrinciplesText">Тестирование программного обеспечения – креативная и интеллектуальная работа. Разработка правильных и эффективных тестов – достаточно непростое занятие. Принципы тестирования, представленные ниже, были разработаны в последние 40 лет и являются общим руководством для тестирования в целом.</string>
    <string name="TestingPrinciplesText1">1. Тестирование показывает наличие дефектов. Тестирование может показать наличие дефектов в программе, но не доказать их отсутствие. Тем не менее, важно составлять тест-кейсы, которые будут находить как можно больше багов. Таким образом, при должном тестовом покрытии, тестирование позволяет снизить вероятность наличия дефектов в программном обеспечении. В то же время, даже если дефекты не были найдены в процессе тестирования, нельзя утверждать, что их нет.</string>
    <string name="TestingPrinciplesText2">2. Исчерпывающее тестирование невозможно. Невозможно провести исчерпывающее тестирование, которое бы покрывало все комбинации пользовательского ввода и состояний системы, за исключениям совсем уж примитивных случаев. Вместо этого необходимо использовать анализ рисков и расстановку приоритетов, что позволит более эффективно распределять усилия по обеспечению качества ПО.</string>
    <string name="TestingPrinciplesText3">3. Раннее тестирование. Тестирование должно начинаться как можно раньше в жизненном цикле разработки программного обеспечения, и его усилия должны быть сконцентрированы на определенных целях.</string>
    <string name="TestingPrinciplesText4">4. Скопление дефектов. Разные модули системы могут содержать разное количество дефектов – то есть, плотность скопления дефектов в разных элементах программы может отличаться. Усилия по тестированию должны распределяться пропорционально фактической плотности дефектов. В основном, большую часть критических дефектов находят в ограниченном количестве модулей. Это проявление принципа Парето: 80% проблем содержатся в 20% модулей.</string>
    <string name="TestingPrinciplesText5">5. Парадокс пестицида. Прогоняя одни и те же тесты вновь и вновь, Вы столкнетесь с тем, что они находят все меньше новых ошибок. Поскольку система эволюционирует, многие из ранее найденных дефектов исправляют и старые тест-кейсы больше не срабатывают. Чтобы преодолеть этот парадокс, необходимо периодически вносить изменения в используемые наборы тестов, рецензировать и корректировать их с тем, чтобы они отвечали новому состоянию системы и позволяли находить как можно большее количество дефектов.</string>
    <string name="TestingPrinciplesText6">6. Тестирование зависит от контекста. Выбор методологии, техники и типа тестирования будет напрямую зависеть от природы самой программы. Например, программное обеспечение для медицинских нужд требует гораздо более строгой и тщательной проверки, чем, скажем, компьютерная игра. Из тех же соображений, сайт с большой посещаемостью должен пройти через серьезное тестирование производительности, чтобы показать возможность работы в условиях высокой нагрузки.</string>
    <string name="TestingPrinciplesText7">7. Заблуждение об отсутствии ошибок. Тот факт, что тестирование не обнаружило дефектов, еще не значит, что программа готова к релизу. Нахождение и исправление дефектов будут не важны, если система окажется неудобной в использовании, и не будет удовлетворять ожиданиям и потребностям пользователя.</string>
    <string name="TestingPrinciplesText8">И еще несколько важных принципов:</string>
    <string name="TestingPrinciplesText8_1">— тестирование должно производиться независимыми специалистами;</string>
    <string name="TestingPrinciplesText8_2">— привлекайте лучших профессионалов;</string>
    <string name="TestingPrinciplesText8_3">— тестируйте как позитивные, так и негативные сценарии;</string>
    <string name="TestingPrinciplesText8_4">— не допускайте изменений в программе в процессе тестирования;</string>
    <string name="TestingPrinciplesText8_5">— указывайте ожидаемый результат выполнения тестов.</string>

    <string name="TestersVocabulary">Словарь тестировщика</string>
    <string name="TestersVocabularyText">Когда Вы начинаете работать в ИТ-сфере, часто сталкиваетесь с ситуацией непонимания некоторых слов и терминов. Чтобы облегчить ваш «вход» в ИТ, сделать его более понятным и комфортным, тренинг-центр QALight подготовил базовый перечень терминов, которые чаще всего используют тестировщики.</string>
    <string name="TestersVocabularyText1">ОБЩИЕ ТЕРМИНЫ:</string>
    <string name="TestersVocabularyText2">Автоматизированное тестирование (Automated testing) — процесс тестирования программного обеспечения, используя специальные программы.</string>
    <string name="TestersVocabularyText3">Альфа-тестирование (Alpha testing) — имитация реальной работы с системой разработчиками, или же реальная работа потенциальных пользователей на ранней стадии разработки продукта.</string>
    <string name="TestersVocabularyText4">Анализ предельных значений (Boundary Value Analysis) — техника проверки поведения продукта на предельных значениях (поля, записи, файлы и т.п.).</string>
    <string name="TestersVocabularyText5">Андерлокинг — снижение частоты работы оборудования.</string>
    <string name="TestersVocabularyText6">Баг (bug) — дефект; несоответствие фактического результата выполнения программы ожидаемому результату.</string>
    <string name="TestersVocabularyText7">Баг-репорт (bug report) — технический документ, содержащий в себе полное описание бага, включающий информацию, как о самом баге (краткое описание, серьезность, приоритет), так и об условиях возникновения этого бага.</string>
    <string name="TestersVocabularyText8">Бета-тестирование (Beta testing) — интенсивное использование почти готовой версии продукта с целью выявить и исправить как можно больше дефектов перед окончательным выпуском для пользователей.</string>
    <string name="TestersVocabularyText9">Валидация (validation) — это процесс оценки конечного продукта, необходимо проверить, соответствует ли программное обеспечение ожиданиям и требованиям клиента. Это динамичный механизм проверки и тестирования фактического продукта.</string>
    <string name="TestersVocabularyText10">Верификация (verification) — это статическая практика проверки документов, дизайна, архитектуры, кода и тому подобное.</string>
    <string name="TestersVocabularyText11">Дебагинг (debugging) — процесс, во время которого находят и исправляют ошибки.</string>
    <string name="TestersVocabularyText12">Дымное тестирования (Smoke test) — проверка выполнения функций продуктом после сборки нового или исправленного текущего кода.</string>
    <string name="TestersVocabularyText13">Эквивалентное разделение (equivalence partitioning) — техника, при которой функционал разделяется на группы значений, эквивалентных по воздействию на систему.</string>
    <string name="TestersVocabularyText14">Жизненный цикл программного обеспечения — это условная схема, включающая в себя отдельные этапы, которые являются стадиями развития процесса создания ПО.</string>
    <string name="TestersVocabularyText15">Обеспечение качества (Quality Assurance, QA) — совокупность мероприятий, охватывающих все технологические этапы разработки, выпуска и использования ПО.</string>
    <string name="TestersVocabularyText16">Сбой (failure) — несоответствие фактического результата работы системы или компонента тому результату, который ожидали.</string>
    <string name="TestersVocabularyText17">Инсталляционное тестирование (Installation Testing) — процесс тестирования стадии установки.</string>
    <string name="TestersVocabularyText18">Итеративная модель (iterative model) — предполагает разбиение проекта на части (этапы, итерации) и прохождение этапов жизненного цикла на каждом из них. Каждый этап является законченным сам по себе, совокупность этапов формирует конечный результат.</string>
    <string name="TestersVocabularyText19">Каскадная модель (waterfall model) — последовательный метод разработки программного обеспечения, названный так из-за диаграммы, похожей на водопад.</string>
    <string name="TestersVocabularyText20">Конфигурационное тестирование (Configuration Testing) — проверка работы программного обеспечения при различных конфигурациях системы.</string>
    <string name="TestersVocabularyText21">Матрица соответствия требованиям (Traceability matrix) — двухмерная таблица, где определено соответствие функциональных требований и подготовленных тестовых сценариев.</string>
    <string name="TestersVocabularyText22">Нагрузочное тестирование (Load testing) — определение работоспособности, стабильности, потребления ресурсов и других атрибутов качества приложения в условиях различных сценариев использования и нагрузок.</string>
    <string name="TestersVocabularyText23">Нефункциональное тестирование (Non-functional testing) — тестирование свойств, которые не отвечают функциональности системы.</string>
    <string name="TestersVocabularyText24">Оверлокинг (Overclocking) — увеличение частоты компонента компьютера с целью увеличения скорости его работы.</string>
    <string name="TestersVocabularyText25">Операционное тестирования (Release Testing) — процесс проверки системы на удовлетворение всех потребностей пользователя и соответствия бизнес-требованиям.</string>
    <string name="TestersVocabularyText26">Ошибка (error) — действие, после которого возникает неправильный результат.</string>
    <string name="TestersVocabularyText27">Предсказание ошибки (Error Guessing) — возможность тестировщика, благодаря своим знаниям и пониманию системы, предсказать, при каких условиях система может выдать ошибку.</string>
    <string name="TestersVocabularyText28">Повторное тестирование (retesting) — тестирование, которое проводиться чтобы убедиться в решении ранее найденных ошибок.</string>
    <string name="TestersVocabularyText29">Пост-релиз (Post-release to manufacturing) — издание продукта с несколькими отличиями от RTM; является самой первой стадией разработки нового продукта.</string>
    <string name="TestersVocabularyText30">Пре-альфа (Pre-alpha) — самая первая стадия разработки — от самого начала до стадии альфа.</string>
    <string name="TestersVocabularyText31">Приемное тестирование (acceptance testing) — тестирование, направленное на проверку продукта с точки зрения конечного пользователя.</string>
    <string name="TestersVocabularyText32">Причина/следствие (Cause/Effect) — введение определенных комбинаций для получения определенного результата.</string>
    <string name="TestersVocabularyText33">Приоритет багов (Priority) — атрибут, указывающий на скорость устранения бага, очередность выполнения задачи.</string>
    <string name="TestersVocabularyText34">Trivial — косметическая малозаметная проблема.</string>
    <string name="TestersVocabularyText35">Minor — очевидная, незначительная проблема.</string>
    <string name="TestersVocabularyText36">Major — большая проблема.</string>
    <string name="TestersVocabularyText37">Critical — проблема, нарушает работу ключевых функций ПО.</string>
    <string name="TestersVocabularyText38">Blocker — проблема, нарушает функционирование ПО.</string>
    <string name="TestersVocabularyText39">Регрессионное тестирование (regression testing) — проверка на наличие ошибок после выполнения определенных действий или внесения изменений в систему.</string>
    <string name="TestersVocabularyText40">Релиз (Release to manufacturing) — выпуск продукта.</string>
    <string name="TestersVocabularyText41">Релиз-кандидат (Release candidate) — предварительный релиз, который имеет потенциал стать окончательным, если не будут выявлены значительные нарушения.</string>
    <string name="TestersVocabularyText42">Ручное тестирование (manual testing) — процесс ручной проверки программного обеспечения на наличие ошибок.</string>
    <string name="TestersVocabularyText43">Санитарное тестирование (Sanity testing) — тестирование определенной функции с целью проверки, соответствует ли ее работа заявленным требованиям.</string>
    <string name="TestersVocabularyText44">Серьезность (Severity) — степень влияния дефекта на работоспособность системы.</string>
    <string name="TestersVocabularyText45">Система отслеживания ошибок (bug tracking system) — система контроля багов.</string>
    <string name="TestersVocabularyText46">Спецификация (specification) — детальное описание того, как должно работать ПО.</string>
    <string name="TestersVocabularyText47">Спиральная модель (spiral model) — все этапы жизненного цикла при спиральной модели идут витками, на каждом из которых происходят проектирование, кодирование, дизайн, тестирование и тому подобное.</string>
    <string name="TestersVocabularyText48">Сравнительное тестирование (Back-To-Back Testing) — анализ плюсов и минусов продукта в сравнении с его ближайшими конкурентами.</string>
    <string name="TestersVocabularyText49">Стадии разработки ПО — определенные этапы, которые проходит команда разработчиков от старта до того, как продукт станет доступен широкой аудитории.</string>
    <string name="TestersVocabularyText50">Стрессовое тестирование — проверка работоспособности продукта во время и после работы с гораздо большей нагрузкой, чем было запланировано.</string>
    <string name="TestersVocabularyText51">Таблица принятия решений (Decision table) — удобный инструмент, цель которого – упорядочить бизнес-требования к продукту.</string>
    <string name="TestersVocabularyText52">Тест-дизайн (Test design) — один из этапов тестирования, во время которого проектируются возможные тест-кейсы (случаи).</string>
    <string name="TestersVocabularyText53">Тест-кейс (Test Case) — это тестовый артефакт, суть которого заключается в выполнении некоторого количества действий и/или условий, необходимых для проверки определенной функциональности программной системы, разрабатываемой системы.</string>
    <string name="TestersVocabularyText54">Тест-план (Test Plan) — документ, в котором указан весь объем работ по тестированию, а также оценки рисков с вариантами их решения.</string>
    <string name="TestersVocabularyText55">Тестирование (Testing) — процесс проверки соответствия заявленных к продукту требований и реально реализованной функциональности, происходит путем наблюдения за его работой в искусственно созданных ситуациях и на ограниченном наборе тестов, выбранных определенным образом.</string>
    <string name="TestersVocabularyText56">Тестирование безопасности (Security testing) — проверка, насколько система готова противостоять злонамеренным попыткам получить доступ к данным.</string>
    <string name="TestersVocabularyText57">Тестирование взаимодействия (Interoperability Testing) — функциональное тестирование, цель которого проверить, как может приложение взаимодействовать с одними или несколькими элементами/системами.</string>
    <string name="TestersVocabularyText58">Тестирование восстановления (recovery testing) — проверка способности продукта восстанавливать свои функции после незапланированной ситуации.</string>
    <string name="TestersVocabularyText59">Тестирование доступности (Accessibility Testing) — используется для выявления возможности использования системы и удобства для людей с ограниченными возможностями.</string>
    <string name="TestersVocabularyText60">Тестирование интернационализации/локализации — проверка готовности продукта к использованию его на разных языках, учитывая национальные и культурные особенности.</string>
    <string name="TestersVocabularyText61">Тестирование пользовательского интерфейса (UI Testing) — тестирование, основная цель которого выявить, удобный ли определенный элемент для использования.</string>
    <string name="TestersVocabularyText62">Тестирование масштабирования (Scalability Test) — изучение возможности увеличивать показатели производительности по мере увеличения количества доступных приложением ресурсов.</string>
    <string name="TestersVocabularyText63">Тестирование сборки (Build Verification Test) — тестирование, цель которого выявить, соответствуют ли требования выпущенной версии критериям качества для начала тестирования.</string>
    <string name="TestersVocabularyText64">Тестирование совместимости (Compatibility testing) — проверка возможности продукта работать в заданных условиях.</string>
    <string name="TestersVocabularyText65">Функциональное тестирование (Functional Testing) — процесс проверки с целью определения функциональных возможностей приложения.</string>
    <string name="TestersVocabularyText66">Чек-лист (Check list) — документ, в котором определен перечень того, что должно быть протестированным.</string>
    <string name="TestersVocabularyText67">QC (Quality Control) — проверка соблюдения требований, предусмотренных в нормативно-технической документации.</string>
    <string name="TestersVocabularyText68">UI (User Interface) — инструмент, помогающий наладить взаимодействие «пользователь-приложение».</string>
    <string name="TestersVocabularyText69">UX (user experience) — ощущения, возникающие у пользователя при взаимодействии с продуктом.</string>
    <string name="TestersVocabularyText70">V-модель (v-model) — модель, на каждом этапе которой осуществляется контроль текущего процесса для того, чтобы убедиться в возможности перехода на следующий уровень.</string>
    <string name="TestersVocabularyText71">Z-конфликт (Z-fighting) — наложение текстур друг на друга.</string>
    <string name="TestersVocabularyText72">ТИПЫ ТЕСТИРОВАНИЯ:</string>
    <string name="TestersVocabularyText73">Мобильное тестирование — тестирование мобильных приложений.</string>
    <string name="TestersVocabularyText74">Консольное тестирования — тестирование приложений для консолей.</string>
    <string name="TestersVocabularyText75">Веб-тестирование — тестирование браузерных приложений.</string>
    <string name="TestersVocabularyText76">ТИПЫ ТЕСТИРОВАНИЯ ПО ЗАПУСКУ КОДА НА ВЫПОЛНЕНИЕ:</string>
    <string name="TestersVocabularyText77">Статическое (Static testing) — тип тестирования, который предполагает, что программный код во время тестирования не будет выполняться.</string>
    <string name="TestersVocabularyText78">Динамическое (Dynamic testing) — тип тестирования, который предусматривает запуск программного кода.</string>
    <string name="TestersVocabularyText79">ТИПЫ ТЕСТИРОВАНИЯ ПО ДОСТУПУ К КОДУ:</string>
    <string name="TestersVocabularyText80">Black box — тестировщик не знает, как устроена тестируемая система.</string>
    <string name="TestersVocabularyText81">White box — тестировщик знает все детали тестируемой системы.</string>
    <string name="TestersVocabularyText82">Grey box — тестировщик знает только о некоторых особенностях тестируемой системы.</string>
    <string name="TestersVocabularyText83">ТИПЫ ТЕСТИРОВАНИЯ ПО ПРИНЦИПУ РАБОТЫ С ПРИЛОЖЕНИЯМИ:</string>
    <string name="TestersVocabularyText84">Положительное тестирования (Positive testing) — процесс тестирования программного обеспечения на то, как оно должно работать.</string>
    <string name="TestersVocabularyText85">Негативное тестирование (Negative testing) — процесс тестирования программного обеспечения на то, как оно не должно работать.</string>
    <string name="TestersVocabularyText86">ТИПЫ ТЕСТИРОВАНИЯ ПО УРОВНЮ ДЕТАЛИЗАЦИИ ПРИЛОЖЕНИЯ:</string>
    <string name="TestersVocabularyText87">Интеграционное тестирование — тестирование взаимодействия нескольких элементов системы.</string>
    <string name="TestersVocabularyText88">Системное тестирование — тестирование всего приложения от начала до конца.</string>
    <string name="TestersVocabularyText89">Модульное тестирование — тестирование определенных компонентов системы.</string>

    <string name="PsychologyOfTesting">Психология тестирования</string>
    <string name="PsychologyOfTestingText">Образ мышления специалиста по тестированию должен отличаться от образа мышления разработчика. Вообще говоря, программисты вполне способны сами тестировать как собственноручно написанный код, так и функциональность системы, над которой они работают. Но тестирование не зря проводится независимыми специалистами – люди склонны неправильно оценивать результаты собственной работы. Поэтому тестировщик, обладающий определенной степенью независимости практически всегда будет эффективнее находить дефекты и сбои в системе, чем программист. Здесь нужно оговориться, что независимость не может быть заменой знаний – определенные задачи гораздо проще и быстрее выполнить программистам, например, провести модульное тестирование, которое требует понимания внутреннего устройства программы.</string>
    <string name="PsychologyOfTestingText1">Всего выделяют четыре уровня независимости – от низкого до высокого:</string>
    <string name="PsychologyOfTestingText2">1. тесты для программы разрабатываются и проводятся человеком, который является ее автором;</string>
    <string name="PsychologyOfTestingText3">2. тесты разрабатываются и выполняются другими людьми (например, другим разработчиком);</string>
    <string name="PsychologyOfTestingText4">3. тесты разработаны представителями другой организационной группы (например, из отдела тестирования) или специализированными тестировщиками (например, специалистами по тестированию производительности или безопасности);</string>
    <string name="PsychologyOfTestingText5">4. тесты разрабатываются и выполняются специалистами из другой организации (например, аутсорсинговой или аудиторской).</string>
    <string name="PsychologyOfTestingText6">В силу своей деятельности, тестировщики занимаются оценкой чужой работы, находят в ней недостатки, что часто воспринимается как деструктивная деятельность, несмотря на то, что ее результатом становится исправление ошибок и улучшение общего качества продукта. Хороший тестировщик должен обладать рядом личных и профессиональных качеств: он должен быть любопытным, критичным, внимательным к деталям, коммуникативным, сохранять профессиональный пессимизм и иметь достаточный опыт для построения предположений о возможных источниках ошибок. Тестировщик, в отличие от программиста, главная цель которого – создать работающий продукт, должен уметь найти все заложенные в этом продукте недостатки. А для этого мы должны, прежде всего, сконцентрироваться на том, что может пойти не так. Исследования показали, что, если человек, тестирующий программу, воспринимает ее как работающую правильно, он найдет меньше ошибок, чем тот, кто будет уверен в наличии в ней множества недостатков. Поэтому, тестировщик должен всегда помнить о том, что “Software has bugs”. И напоследок, еще один важный момент: при написании отчета о дефекте будьте объективны и ни в коем случае не указывайте явно или неявно на его виновника, даже если он вполне того заслуживает. Помните, Вам с программистами еще работать, не стоит портить отношения.</string>
    <string name="PsychologyOfTestingText7">Есть несколько простых советов для улучшения коммуникации с коллегами:</string>
    <string name="PsychologyOfTestingText8">– помните о том, что все вы работаете над одним проектом и идете к одной цели – созданию качественного и востребованного продукта;</string>
    <string name="PsychologyOfTestingText9">– оформляйте результаты своей работы в нейтральном тоне, сфокусируйтесь на фактах;</string>
    <string name="PsychologyOfTestingText10">– поставьте себя на место других и попытайтесь понять причины их поведения;</string>
    <string name="PsychologyOfTestingText11">– всегда убеждайтесь в том, что другой человек понял Вас, а Вы его.</string>

    <string name="manualAndAutomated">Ручное и автоматизированное тестирование</string>
    <string name="manualAndAutomatedText">При ручном тестировании (manualtesting) тестировщики вручную выполняют тесты, не используя никаких средств автоматизации.Ручное тестирование – самый низкоуровневый и простой тип тестирования, не требующих большого количества дополнительных знаний.Тем не менее, перед тем как автоматизировать тестирование любого приложения, необходимо сначала выполнить серию тестов вручную.Мануальное тестирование требует значительных усилий, но без него мы не сможем убедиться в том, возможна ли автоматизация в принципеОдин из фундаментальных принципов тестирования гласит: 100% автоматизация невозможна. Поэтому, ручное тестирование – необходимость.</string>
    <string name="manualAndAutomatedText1">Мифы о ручном тестировании:</string>
    <string name="manualAndAutomatedText2">– кто угодно может провести ручное тестирование.</string>
    <string name="manualAndAutomatedText3">    Нет, выполнение любого вида тестирования требует специальных знаний и профессиональной подготовки.</string>
    <string name="manualAndAutomatedText4">– автоматизированное тестирование мощнее ручного.</string>
    <string name="manualAndAutomatedText5">    Полная автоматизация невозможна. Необходимо использовать также и ручное тестирование.</string>
    <string name="manualAndAutomatedText6">– ручное тестирование – это просто.</string>
    <string name="manualAndAutomatedText7">    Тестирование может быть очень непростым занятием. Проведение тестирования для проверки максимально возможного количества путей выполнения с использованием минимального числа тест-кейсов требует серьезных аналитических навыков.</string>
    <string name="manualAndAutomatedText8">    Автоматизированное тестирование предполагает использование специального программного обеспечения (помимо тестируемого) для контроля выполнения тестов и сравнения ожидаемого  фактического результата работы программы. Этот тип тестирования помогает автоматизировать часто повторяющиеся, но необходимые для максимизации тестового покрытия задачи. Некоторые задачи тестирования, такие как низкоуровнево регрессионное тестирование,  могут быть трудозатратными и требующими много времени если выполнять их вручную. Кроме того, мануально тестирование может недостаточно эффективно находить некоторые классы ошибок. В таких случаях автоматизация может помочь сэкономить время и усилия проектной команды. После создания автоматизированных тестов, их можно в любой момент запустить снова, причем запускаются и выполняются они быстро и точно. Таким образом, если есть необходимость частого повторного прогона тестов, значение автоматизации для упрощения сопровождения проекта снижения его стоимости трудно переоценить. Ведь даже минимальные патчи и изменения кода могут стать причиной появления новых багов.</string>
    <string name="manualAndAutomatedText9">Существует несколько основных видов автоматизированного тестирования:</string>
    <string name="manualAndAutomatedText10">– автоматизация тестирования кода (Code-driven testing) – тестирование на уровне программных модулей, классов и библиотек (фактически, автоматические юнит-тесты);</string>
    <string name="manualAndAutomatedText11"> – автоматизация тестирования графического пользовательского интерфейса (Graphical user interface testing) – специальная программа (фреймворк автоматизации тестирования) позволяет генерировать пользовательские события – нажатия клавиш, клики мышкой, и отслеживат реакцию программы на эти действия – соответствует ли она спецификации.</string>
    <string name="manualAndAutomatedText12">– автоматизация тестирования API (ApplicationProgrammingInterface) – программного интерфейса программы. Тестируются интерфейсы предназначенные для взаимодействия, например, с другими программами или с пользователем. Здесь опять же, как правило, используются специальные фреймворки.</string>
    <string name="manualAndAutomatedText13">    Для составления автоматизированных тестов, QA-специалист должен уметь программировать. Автоматические тесты – это полноценные программы, просто предназначенные для тестирования. Когда, что и как автоматизировать и автоматизировать ли вообще – очень важные вопросы, ответы на которые должна дать команда разработки. Выбор правильных элементов программы для автоматизации в большой степени будет определять успех автоматизации тестирования в принципе. Нужно избегать автоматизации тестирования участков кода, которые могут часто меняться.</string>
    <string name="manualAndAutomatedText14">Сравнение ручного и автоматизированного тестирования.</string>
    <string name="manualAndAutomatedText15">    Как ручное, так и автоматизированное тестирование могут использоваться на разных уровнях тестирования, а также быть частью других типов и видов тестирования. Автоматизация сохраняет время, силы и деньги. Однажды автоматизированный тест можно запускать снова и снова, прилагая минимум усилий. Вручную можно протестировать практически любое приложение, в то время как автоматизировать стоит только стабильные системы. Автоматизированное тестирование используется главным образом для регрессии. Кроме того, некоторые виды тестирования, например, ad-hoc или исследовательское тестирование могут быть выполнены только вручную.</string>
    <string name="manualAndAutomatedText16">    Мануальное тестирование может быть повторяющимся и скучным. В то же время, автоматизация может помочь этого избежать – за вас все сделает компьютер. Таким образом, на реальных проектах зачастую используется комбинация ручного и автоматизированного тестирования, причем уровень автоматизации будет зависеть как от типа проекта, так и от особенностей постановки производственных процессов в компании.</string>

    <string name="lifeCycle">Жизненный цикл ПО</string>
    <string name="lifeCycleText">Тестирование – не изолированный процесс. Это часть модели жизненного цикла программного обеспечения (Software Development Life Cycle, SDLC). Именно поэтому выбор средств и методик тестирования будет напрямую зависеть от выбранной модели разработки. В этом разделе мы рассмотрим наиболее часто применяемые подходы к разработке программного обеспечения, а также популярные сегодня методологии и практики, такие как Agile и Scrum. Жизненный цикл программного обеспечения (также называемый циклом разработки) – это условная схема, включающая отдельные этапы, которые представляют стадии процесса создания ПО. При этом на каждом этапе выполняются разные действия.</string>
    <string name="lifeCycleText1">ФОТО</string>
    <string name="lifeCycleText2">Цикл разработки предлагает шаблон, использование которого облегчает проектирование, создание и выпуск качественного программного обеспечения. Это методология, определяющая процессы и средства, необходимые для успешного завершения проекта. Хотя реализация принципов построения модели жизненного цикла для разных компаний может существенно отличаться, существуют стандарты, такие как ISO/IEC 12207, определяющие принятые практики разработки и сопровождения программного обеспечения. Цель использования модели жизненного цикла – создать эффективный, экономически выгодный и качественный программный продукт.</string>

    <string name="spiralModel">Спиральная модель</string>
    <string name="spiralModelText">Спиральная модель представляет шаблон процесса разработки ПО, который сочетает идеи итеративной и каскадной моделей. Суть ее в том, что весь процесс создания конечного продукта представлен в виде условной плоскости, разбитой на 4 сектора, каждый из которых представляет отдельные этапы его разработки: определение целей, оценка рисков, разработка и тестирование, планирование новой итерации.</string>
    <string name="spiralModelText1">В спиральной модели жизненный путь разрабатываемого продукта изображается в виде спирали, которая, начавшись на этапе планирования, раскручивается с прохождением каждого следующего шага. Таким образом, на выходе из очередного витка мы должны получить готовый протестированный прототип, который дополняет существующий билд. Прототип, удовлетворяющий всем требованиям – готов к релизу.</string>
    <string name="spiralModelText2">Главная особенность спиральной модели – концентрация на возможных рисках. Для их оценки даже выделена соответствующая стадия. Основные типы рисков, которые могут возникнуть в процессе разработки ПО:</string>
    <string name="spiralModelText3">— Нереалистичный бюджет и сроки;</string>
    <string name="spiralModelText4">— Дефицит специалистов;</string>
    <string name="spiralModelText5">— Частые изменения требований;</string>
    <string name="spiralModelText6">— Чрезмерная оптимизация;</string>
    <string name="spiralModelText7">— Низкая производительность системы;</string>
    <string name="spiralModelText8">— Несоответствие уровня квалификации специалистов разных отделов.</string>
    <string name="spiralModelText9">Плюсы спиральной модели:</string>
    <string name="spiralModelText10">   улучшенный анализ рисков;</string>
    <string name="spiralModelText11">   хорошая документация процесса разработки;</string>
    <string name="spiralModelText12">   гибкость – возможность внесения изменений и добавления новой функциональности даже на относительно поздних этапах;</string>
    <string name="spiralModelText13">   раннее создание рабочих прототипов.</string>
    <string name="spiralModelText14">Минусы спиральной модели:</string>
    <string name="spiralModelText15">   может быть достаточно дорогой в использовании;</string>
    <string name="spiralModelText16">   управление рисками требует привлечения высококлассных специалистов;</string>
    <string name="spiralModelText17">   успех процесса в большой степени зависит от стадии анализа рисков;</string>
    <string name="spiralModelText18">   не подходит для небольших проектов.</string>
    <string name="spiralModelText19">Когда использовать спиральную модель:</string>
    <string name="spiralModelText20">   когда важен анализ рисков и затрат;</string>
    <string name="spiralModelText21">   крупные долгосрочные проекты с отсутствием четких требований или вероятностью их динамического изменения;</string>
    <string name="spiralModelText22">   при разработке новой линейки продуктов.</string>

</resources>